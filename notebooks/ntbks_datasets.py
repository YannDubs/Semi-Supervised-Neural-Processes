import math
from PIL import Image

import numpy as np
import torch
from torch.utils.data import Dataset
from sklearn.gaussian_process.kernels import RBF
from sklearn.gaussian_process import GaussianProcessRegressor

__all__ = ["SineDataset", "GPDataset"]


class GPDataset(Dataset):
    """
    Dataset of functions generated by a gaussian process.

    Parameters
    ----------
    kernel : sklearn.gaussian_process.kernels
        The kernel specifying the covariance function of the GP. If None is
        passed, the kernel "1.0 * RBF(1.0)" is used as default.

    num_samples : int, optional
        Number of sampled functios contained in dataset.

    num_points : int, optional
        Number of points at which to evaluate f(x) for x in min_max.

    min_max : tuple of floats, optional
        Min and max point at which to evaluate the function (bounds).
    """

    def __init__(self,
                 kernel=1. * RBF(length_scale=1.),
                 min_max=(-5, 5),
                 num_samples=1000,
                 num_points=100):

        self.num_samples = num_samples
        self.num_points = num_points
        self.min_max = min_max
        self.gp = GaussianProcessRegressor(kernel=kernel)

        self.data = torch.from_numpy(np.linspace(*self.min_max, num_points))
        self.data = self.data.view(1, -1, 1)
        self.data = self.data.expand(self.num_samples, self.num_points, 1).float()
        self.precompute_data()

    def precompute_data(self):
        self.counter = 0
        X_ = np.linspace(*self.min_max, self.num_points)  # could take the one from self.data
        y_samples = self.gp.sample_y(X_[:, np.newaxis], self.num_samples).transpose(1, 0)
        y_samples = torch.from_numpy(y_samples)
        self.targets = y_samples.view(self.num_samples, self.num_points, 1).float()

    def __getitem__(self, index):
        # doesn't use index because randomly gnerated in any case => sample
        # in order which enables to know when epoch is finished and regenerate
        # new functions
        self.counter += 1
        if self.counter == self.num_samples:
            self.precompute_data()
        return self.data[self.counter], self.targets[self.counter]

    def __len__(self):
        return self.num_samples


class SineDataset(Dataset):
    """
    Dataset of functions f(x) = a * sin(x - b) where a and b are randomly
    sampled.

    Notes
    -----
    - modified from: https://github.com/EmilienDupont/neural-processes/

    Parameters
    ----------
    amplitude_range : tuple of float, optional
        Defines the range from which the amplitude (i.e. a) of the sine function
        is sampled.

    shift_range : tuple of float, optional
        Defines the range from which the shift (i.e. b) of the sine function is
        sampled.

    num_samples : int, optional
        Number of sampled functios contained in dataset.

    num_points : int, optional
        Number of points at which to evaluate f(x) for x in min_max.

    std_noise : float, optional
        Standard deviation of the noise to add

    min_max : tuple of floats, optional
        Min and max point at which to evaluate the function (bounds).
    """

    def __init__(self,
                 amplitude_range=(-1., 1.),
                 shift_range=(-.5, .5),
                 num_samples=1000,
                 num_points=100,
                 std_noise=0.01,
                 min_max=(-math.pi, math.pi)):

        self.amplitude_range = amplitude_range
        self.shift_range = shift_range
        self.num_samples = num_samples
        self.num_points = num_points
        self.x_dim = 1  # x and y dim are fixed for this dataset.
        self.y_dim = 1
        self.std_noise = std_noise
        self.min_max = min_max

        # Generate data
        a_min, a_max = amplitude_range
        b_min, b_max = shift_range
        # Sample random amplitude
        a = (a_max - a_min) * torch.rand(num_samples, 1, self.y_dim) + a_min
        # Sample random shift
        b = (b_max - b_min) * torch.rand(num_samples, 1, self.y_dim) + b_min
        # Shape (num_samples, num_points, x_dim)
        self.data = torch.linspace(*self.min_max, num_points)
        self.data = self.data.view(1, -1, 1).expand(self.num_samples, self.num_points, self.x_dim)
        # Shape (num_samples, num_points, y_dim)
        self.targets = (a * torch.sin(self.data - b)
                        ) + torch.randn_like(self.data) * self.std_noise

    def __getitem__(self, index):
        return self.data[index], self.targets[index]

    def __len__(self):
        return self.num_samples
