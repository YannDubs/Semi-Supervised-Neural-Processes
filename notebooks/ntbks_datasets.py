import math
from PIL import Image

import numpy as np
import torch
from torch.utils.data import Dataset
from sklearn.gaussian_process.kernels import RBF
from sklearn.gaussian_process import GaussianProcessRegressor

__all__ = ["SineDataset", "GPDataset"]


class GPDataset(Dataset):
    """
    Dataset of functions generated by a gaussian process.

    Parameters
    ----------
    kernel : sklearn.gaussian_process.kernels
        The kernel specifying the covariance function of the GP. If None is
        passed, the kernel "1.0 * RBF(1.0)" is used as default.

    num_samples : int, optional
        Number of sampled functios contained in dataset.

    num_points : int, optional
        Number of points at which to evaluate f(x) for x in min_max.

    min_max : tuple of floats, optional
        Min and max point at which to evaluate the function (bounds).
    """

    def __init__(self,
                 kernel=1. * RBF(length_scale=1.),
                 min_max=(-5, 5),
                 num_samples=1000,
                 num_points=100):

        self.num_samples = num_samples
        self.num_points = num_points
        self.min_max = min_max

        self.gp = GaussianProcessRegressor(kernel=kernel)

        X_ = np.linspace(*min_max, num_points)
        y_samples = self.gp.sample_y(X_[:, np.newaxis], num_samples).transpose(1, 0)

        self.data = torch.from_numpy(X_)
        self.data = self.data.view(1, -1, 1).expand(self.num_samples, self.num_points, 1).float()
        self.targets = torch.from_numpy(y_samples).view(self.num_samples, self.num_points, 1).float()

    def __getitem__(self, index):
        return self.data[index], self.targets[index]

    def __len__(self):
        return self.num_samples


class SineDataset(Dataset):
    """
    Dataset of functions f(x) = a * sin(x - b) where a and b are randomly
    sampled.

    Notes
    -----
    - modified from: https://github.com/EmilienDupont/neural-processes/

    Parameters
    ----------
    amplitude_range : tuple of float, optional
        Defines the range from which the amplitude (i.e. a) of the sine function
        is sampled.

    shift_range : tuple of float, optional
        Defines the range from which the shift (i.e. b) of the sine function is
        sampled.

    num_samples : int, optional
        Number of sampled functios contained in dataset.

    num_points : int, optional
        Number of points at which to evaluate f(x) for x in min_max.

    std_noise : float, optional
        Standard deviation of the noise to add

    min_max : tuple of floats, optional
        Min and max point at which to evaluate the function (bounds).
    """

    def __init__(self,
                 amplitude_range=(-1., 1.),
                 shift_range=(-.5, .5),
                 num_samples=1000,
                 num_points=100,
                 std_noise=0.01,
                 min_max=(-math.pi, math.pi)):

        self.amplitude_range = amplitude_range
        self.shift_range = shift_range
        self.num_samples = num_samples
        self.num_points = num_points
        self.x_dim = 1  # x and y dim are fixed for this dataset.
        self.y_dim = 1
        self.std_noise = std_noise
        self.min_max = min_max

        # Generate data
        a_min, a_max = amplitude_range
        b_min, b_max = shift_range
        # Sample random amplitude
        a = (a_max - a_min) * torch.rand(num_samples, 1, self.y_dim) + a_min
        # Sample random shift
        b = (b_max - b_min) * torch.rand(num_samples, 1, self.y_dim) + b_min
        # Shape (num_samples, num_points, x_dim)
        self.data = torch.linspace(*self.min_max, num_points)
        self.data = self.data.view(1, -1, 1).expand(self.num_samples, self.num_points, self.x_dim)
        # Shape (num_samples, num_points, y_dim)
        self.targets = (a * torch.sin(self.data - b)
                        ) + torch.randn_like(self.data) * self.std_noise

    def __getitem__(self, index):
        return self.data[index], self.targets[index]

    def __len__(self):
        return self.num_samples
